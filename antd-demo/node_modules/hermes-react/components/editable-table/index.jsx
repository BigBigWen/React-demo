import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Form, Table, Input, Button } from 'antd';
import clonedeep from 'lodash.clonedeep';
import './style/index';

const FormItem = Form.Item;
const noop = () => {};

class EditableTable extends Component {
  static propTypes = {
    className: PropTypes.string,
    empty: PropTypes.bool,
    rowEdit: PropTypes.oneOfType([
      PropTypes.bool,
      PropTypes.object
    ]),
    onSaveTable: PropTypes.func,
    onSaveRow: PropTypes.func
  }

  static defaultProps = {
    className: '',
    empty: false,
    rowEdit: false,
    onSaveTable: noop,
    onSaveRow: noop
  }

  constructor(props) {
    super(props);
    this.sourceKeyList = [];
    this.originRowClassName = this.props.rowClassName;
    this.state = {
      tableEditing: false,
      rowEditing: false,
      savingTable: false,
      savingRow: false,
      tables: this.handleTableProps(),
      editRowIndex: -1
    };

    this.editTable = this.editTable.bind(this);
    this.saveTable = this.saveTable.bind(this);
    this.cancelTable = this.cancelTable.bind(this);
    this.editRow = this.editRow.bind(this);
    this.saveRow = this.saveRow.bind(this);
    this.cancelRow = this.cancelRow.bind(this);
  }

  shouldComponentUpdate() {
    this.handleTableProps();
    return true;
  }

  handleTableProps() {
    const { getFieldProps } = this.props.form;
    const { rowEdit } = this.props;
    const tableProps = clonedeep(this.props);
    if (Object.hasOwnProperty.call(tableProps, 'className')) {
      delete tableProps.className;
    }
    if (Object.hasOwnProperty.call(tableProps, 'empty')) {
      delete tableProps.empty;
    }
    if (Object.hasOwnProperty.call(tableProps, 'rowEdit')) {
      delete tableProps.rowEdit;
    }
    if (Object.hasOwnProperty.call(tableProps, 'onSaveTable')) {
      delete tableProps.onSaveTable;
    }
    if (Object.hasOwnProperty.call(tableProps, 'onSaveRow')) {
      delete tableProps.onSaveRow;
    }

    const { columns } = tableProps;

    columns.map((col) => {
      if (col.editable) {
        const originRender = col.render;
        col.render = (text, record, index) => {
          return (
            <div className="hermes-editable-td">
              <div className="hermes-editable-origin">
                { originRender ? originRender(text, record, index) : text }
              </div>
              <FormItem className="hermes-editable-form-item">
                {
                  col.formItem ? col.formItem(getFieldProps, col.dataIndex + (index + 1), text)
                    : <Input
                      {...getFieldProps(col.dataIndex + (index + 1), {
                        initialValue: text
                      })} />
                }
              </FormItem>
            </div>
          );
        };
      }

      if (Object.prototype.hasOwnProperty.call(col, 'editable')) {
        this.sourceKeyList.push(col.dataIndex);
        delete col.editable;
      }

      if (Object.prototype.hasOwnProperty.call(col, 'verify')) {
        delete col.verify;
      }

      return col;
    });

    if (rowEdit) {
      let operation = {
        title: rowEdit.title || '操作',
        key: rowEdit.key || 'operation',
        dataIndex: rowEdit.dataIndex || 'operation',
        render: (text, record, index) => {
          const originRender = rowEdit.render;
          const { rowEditing, tableEditing, savingRow, editRowIndex } = this.state;
          const edit = (
            <div className="edit-row-wrapper">
              <span className={`edit-row-btn${tableEditing ? ' disabled' : ''}`} onClick={() => { this.editRow(index); }} style={{ display: ((rowEditing && index === editRowIndex) ? 'none' : 'inline') }}>编辑</span>
              <div className="handel-row-edit" style={{ display: ((rowEditing && index === editRowIndex) ? 'inline' : 'none') }}>
                <span className="edit-row-btn" onClick={(e) => { this.saveRow(index, e); }}>保存</span>
                <span className="ft-bar">|</span>
                <span className={`edit-row-btn${savingRow ? ' disabled' : ''}`} onClick={this.cancelRow}>取消</span>
              </div>
            </div>
          );
          return (
            <div className="hermes-edit-row">
              { originRender ? originRender(text, record, index, edit) : edit }
            </div>
          );
        }
      };
      if (rowEdit.width) operation.width = rowEdit.width;
      if (rowEdit.className) operation.className = rowEdit.className;
      if (rowEdit.fixed) operation.className = rowEdit.fixed;
      columns.push(operation);
    }

    return tableProps;
  }

  editTable() {
    if (this.state.tableEditing) return;
    this.setState({
      tableEditing: true
    });
  }

  saveTable(e) {
    e.preventDefault();
    if (this.state.savingTable) return;
    this.props.form.validateFields((errors, values) => {
      if (!errors) {
        this.setState({
          savingTable: true
        });

        const dataSource = this.state.tables.dataSource;
        dataSource.map((data, idx) => {
          this.sourceKeyList.map((item) => {
            if (values[item + (idx + 1)]) {
              data[item] = values[item + (idx + 1)];
            }
            return data[item];
          });
          return data;
        });
        const savePro = async () => {
          await this.props.onSaveTable(clonedeep(dataSource));
        };

        savePro().then(() => {
          dataSource.map((item) => {
            Object.keys(item).map((i) => {
              if (item[i] instanceof Array) {
                item[i] = item[i].join(',');
              }
              return item[i];
            });
            return item;
          });

          this.setState({
            savingTable: false,
            tableEditing: false
          });
        });
      }
    });
  }

  cancelTable() {
    if (!this.state.tableEditing) return;
    this.setState({
      tableEditing: false
    });
    if (this.props.empty) {
      this.props.form.resetFields();
    }
  }

  editRow(idx) {
    if (this.state.tableEditing) return;

    let rowClassName = (record, index) => {
      let temp = this.originRowClassName ? `${this.originRowClassName(record, index)} ` : '';
      return (idx === index) ? `${temp}row-editing` : `${temp}`;
    };
    this.state.tables.rowClassName = rowClassName;
    this.setState({
      rowEditing: true,
      editRowIndex: idx
    });
  }

  saveRow(idx, e) {
    e.preventDefault();
    if (this.state.savingRow) return;
    this.props.form.validateFields((errors, values) => {
      if (!errors) {
        this.setState({
          savingRow: true
        });

        const dataSource = this.state.tables.dataSource[idx];
        Object.keys(dataSource).map((i) => {
          if (values[i + (idx + 1)]) {
            dataSource[i] = values[i + (idx + 1)];
          }
          return dataSource[i];
        });
        const savePro = async () => {
          await this.props.onSaveRow(clonedeep(dataSource), idx);
        };

        savePro().then(() => {
          let rowClassName = (record, index) => {
            let temp = this.originRowClassName ? `${this.originRowClassName(record, index)} ` : '';
            return temp;
          };
          this.state.tables.rowClassName = rowClassName;
          Object.keys(dataSource).map((item) => {
            if (dataSource[item] instanceof Array) {
              dataSource[item] = dataSource[item].join(',');
            }
            return dataSource[item];
          });
          this.setState({
            savingRow: false,
            rowEditing: false
          });
        });
      }
    });
  }

  cancelRow() {
    if (!this.state.rowEditing) return;
    let rowClassName = (record, index) => {
      let temp = this.originRowClassName ? `${this.originRowClassName(record, index)} ` : '';
      return temp;
    };
    this.state.tables.rowClassName = rowClassName;
    this.setState({
      rowEditing: false,
      editRowIndex: -1
    });
    if (this.props.empty) {
      this.props.form.resetFields();
    }
  }

  findParent(ele, parentTag) {
    let parentNode = ele.parentNode;
    while (parentNode) {
      if (parentNode.tagName.toLowerCase() === parentTag) break;
      parentNode = parentNode.parentNode;
    }
    return parentNode;
  }

  render() {
    const { className } = this.props;
    const { tableEditing, rowEditing, saving, tables } = this.state;

    return (
      <div className={`hermes-editable-table-block${tableEditing ? ' table-editing' : ''}${className.length ? ` ${className}` : ''}`}>
        <Form>
          <div className={`hermes-edit-btn-group${tableEditing ? ' toggleBtn' : ''}`}>
            <Button type="primary" onClick={this.editTable} disabled={rowEditing}>编辑</Button>
            <Button type="primary" onClick={this.saveTable} loading={saving}>保存</Button>
            <Button onClick={this.cancelTable} disabled={saving}>取消</Button>
          </div>
          <Table {...tables} />
        </Form>
      </div>
    );
  }
}

/* eslint-disable */
EditableTable = Form.create({})(EditableTable);

export default EditableTable;
