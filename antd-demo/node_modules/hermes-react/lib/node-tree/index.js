'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _class, _temp;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

require('./style/index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var NodeTree = (_temp = _class = function (_Component) {
  _inherits(NodeTree, _Component);

  function NodeTree(props) {
    _classCallCheck(this, NodeTree);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.state = {
      path: [],
      treeData: []
    };
    // if (props.defaultPath && props.defaultPath.length > 0) {
    //   this.state.path = props.defaultPath;
    // }
    _this.rowLeft = [];
    _this.reactKey = 0;

    _this.onClickNode = _this.onClickNode.bind(_this);
    return _this;
  }

  NodeTree.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    if (this.props.defaultPath && this.props.defaultPath.length > 0) {
      this.recursiveNodeInit(true);
    } else {
      this.props.onLoadData().then(function (d) {
        var treeData = d;
        treeData[0].nodeLayoutId = 0 + '_' + 0; // 根结点
        treeData[0].reactKey = _this2.reactKey++;
        _this2.setState({ treeData: treeData });
      });
    }
  };

  NodeTree.prototype.recursiveNodeInit = function recursiveNodeInit(first, nodeInfo, treeData, cur) {
    var _this3 = this;

    if (first === true) {
      // 根节点初始化
      this.props.onLoadData().then(function (d) {
        treeData = d;
        treeData[0].nodeLayoutId = 0 + '_' + 0;
        treeData[0].reactKey = _this3.reactKey++;
        var curPathPos = 0;
        _this3.recursiveNodeInit(false, treeData[0], treeData, curPathPos);
      });
    } else if (cur === this.props.defaultPath.length) {
      // 初始路径已经加载完毕
      var path = this.props.defaultPath.map(function (item, index) {
        return index + '_' + item;
      });
      this.setState({ treeData: treeData, path: path });
    } else {
      // 中间状态
      this.props.onLoadData(nodeInfo).then(function (d) {
        var curPathPos = cur + 1;
        var defaultPath = _this3.props.defaultPath;

        var path = _this3.props.defaultPath.slice(0, curPathPos).map(function (item, index) {
          return index + '_' + item;
        });
        treeData = _this3.appendTreeData(d, path, treeData);
        var node = void 0;
        if (nodeInfo.children && nodeInfo.children.length > 0) {
          nodeInfo.children.forEach(function (item) {
            if (item.nodeLayoutId === curPathPos + '_' + defaultPath[curPathPos]) {
              node = item;
            }
          });
        } else {
          _this3.setState({ treeData: treeData, path: path });
          return;
        }
        if (!node) {
          _this3.setState({ treeData: treeData, path: path });
          return;
        }
        _this3.recursiveNodeInit(false, node, treeData, curPathPos);
      });
    }
  };

  NodeTree.prototype.onClickNode = function onClickNode(e) {
    var path = this.state.path;
    var brotherIndex = -1;
    var shouldGetChildren = false;
    var target = e.target;
    var position = '';
    while (target.getAttribute('data-layoutId') === null || target.parentElement === null) {
      target = target.parentElement;
    }
    position = target.getAttribute('data-layoutId');
    var arrIndex = path.indexOf(position);

    for (var i = 0; i < path.length; i++) {
      if (position.split('_')[0] === path[i].split('_')[0] && position.split('_')[1] !== path[i].split('_')[1]) {
        // 同级但是是兄弟元素而不是自身
        brotherIndex = i;
        break;
      }
    }

    if (arrIndex !== -1) {
      // 点击自身
      path.splice(arrIndex);
    } else if (brotherIndex !== -1) {
      // 点击同级兄弟节点
      path.splice(brotherIndex);
      path.push(position);
      if (!JSON.parse(target.getAttribute('data-hasChildren'))) {
        shouldGetChildren = true;
      }
    } else {
      // 点击下级
      path.push(position);
      if (!JSON.parse(target.getAttribute('data-hasChildren'))) {
        shouldGetChildren = true;
      }
    }
    this.setState({ path: path });
    if (shouldGetChildren) {
      (function cb(me, p) {
        me.props.onLoadData(me.getNode(target.getAttribute('data-layoutId'))).then(function (d) {
          var treeData = me.appendTreeData(d, p);
          me.setState({ treeData: treeData });
        });
      })(this, JSON.parse(JSON.stringify(path)));
    }
  };

  NodeTree.prototype.getNode = function getNode(nodeId) {
    var treeData = this.state.treeData;
    var level = Number.parseInt(nodeId.split('_')[0], 10);
    var parent = {};
    var currentTreeLayer = treeData; // root layer

    for (var i = 0; i <= level; i++) {
      parent = currentTreeLayer[Number.parseInt(this.state.path[i].split('_')[1], 10)];
      if (parent.children && parent.children.length > 0) {
        currentTreeLayer = parent.children;
      }
    }

    return parent;
  };

  NodeTree.prototype.appendTreeData = function appendTreeData(children, path, data) {
    var treeData = data || this.state.treeData;
    var level = Number.parseInt(path[path.length - 1].split('_')[0], 10);
    var parent = {};
    var currentTreeLayer = treeData; // root layer
    var that = this;

    for (var i = 0; i <= level; i++) {
      parent = currentTreeLayer[Number.parseInt(path[i].split('_')[1], 10)];
      if (parent.children && parent.children.length > 0) {
        currentTreeLayer = parent.children;
      }
    }
    children.forEach(function (item, index) {
      item.nodeLayoutId = level + 1 + '_' + index;
      item.reactKey = that.reactKey++;
    });

    parent.children = children;

    return treeData;
  };

  NodeTree.prototype.buildLayer = function buildLayer(layout, layerData) {
    var layer = [];
    var isChosen = false;
    var style = {};

    for (var i = 0; i < layerData.length; i++) {
      if (this.state.path.indexOf(layerData[i].nodeLayoutId) !== -1) {
        isChosen = true;
      } else {
        isChosen = false;
      }
      style = {
        width: layerData[i].nodeLayoutId === '0_0' ? this.props.rootSize.width : this.props.childSize.width,
        height: layerData[i].nodeLayoutId === '0_0' ? this.props.rootSize.height : this.props.childSize.height,
        lineHeight: (layerData[i].nodeLayoutId === '0_0' ? this.props.rootSize.height : this.props.childSize.height) + 'px',
        marginRight: i === layerData.length - 1 ? 0 : this.props.divid.brother
      };
      layer.push(_react2["default"].createElement(_node2["default"], {
        key: layerData[i].reactKey.toString(),
        nodeRender: this.props.renderNode,
        onClick: this.onClickNode,
        nodeData: layerData[i],
        isChosen: isChosen,
        style: style
      }));
      if (this.state.path.indexOf(layerData[i].nodeLayoutId) !== -1 && layerData[i].children && layerData[i].children.length > 0) {
        this.buildLayer(layout, layerData[i].children);
      }
    }
    layout.push(layer);
  };

  NodeTree.prototype.buildPathAndMsg = function buildPathAndMsg() {
    if (this.state.path.length === 0) {
      // 没有结点被展开
      return '';
    }
    var _props = this.props,
        divid = _props.divid,
        rootSize = _props.rootSize,
        childSize = _props.childSize,
        backwards = _props.backwards;

    var lines = [];
    var focusLines = [];
    var texts = [];
    var path = backwards ? JSON.parse(JSON.stringify(this.state.path)).reverse() : this.state.path;
    var rowLeft = backwards ? JSON.parse(JSON.stringify(this.rowLeft)).reverse() : this.rowLeft;
    var offset = backwards ? 0 : 1;
    var children = [];
    var rowAndCol = [];
    var pathObject = {};
    var textObject = {};
    var svgWidth = 0;
    var svgHeight = path.length * (childSize.height + divid.parent) + (rootSize.height + divid.parent);
    var startX = void 0;
    var startY = void 0;
    var endX = void 0;
    var endY = void 0;

    for (var i = 0; i < path.length; i++) {
      var _getNode = this.getNode(path[i]);

      children = _getNode.children;

      if (!children || children.length === 0) {
        break;
      }
      if (rowLeft[i + (backwards ? 0 : 1)] + children.length * (childSize.width + divid.brother) > svgWidth) {
        svgWidth = rowLeft[i + (backwards ? 0 : 1)] + children.length * (childSize.width + divid.brother);
      }
      rowAndCol = path[i].split('_').map(function (item) {
        return Number.parseInt(item, 10);
      });
      if (!this.props.backwards) {
        // 正序排列
        if (i === 0) {
          // 根结点
          startY = divid.parent + rootSize.height;
          startX = 0.5 * rootSize.width + rowLeft[i];
          endY = startY + divid.parent;
        } else {
          startY = rowAndCol[0] * (divid.parent + childSize.height) + (divid.parent + rootSize.height);
          startX = rowAndCol[1] * (divid.brother + childSize.width) + 0.5 * childSize.width + rowLeft[i];
          endY = startY + divid.parent;
        }
      } else {
        // 倒序排列
        var size = i === path.length - 1 ? rootSize : childSize;
        endY = (path.length - rowAndCol[0] - 1) * (divid.parent + size.height) + (divid.parent + size.height);
        startX = rowAndCol[1] * (divid.brother + childSize.width) + 0.5 * childSize.width + rowLeft[i + 1];
        startY = endY + divid.parent;
      }

      // 处理结点中的连线
      for (var j = 0; j < children.length; j++) {
        endX = j * (divid.brother + childSize.width) + 0.5 * childSize.width + rowLeft[i + offset];
        pathObject = { startX: startX, startY: startY, endX: endX, endY: endY };
        if (path.indexOf(children[j].nodeLayoutId) !== -1) {
          focusLines.push(pathObject); // 两个选中结点之间的连线
        } else {
          lines.push(pathObject); // 普通连线
        }
      }

      // 处理结点上额外的文字数据
      if (this.props.extraMsg && this.props.extraMsg !== '') {
        for (var k = 0; k < children.length; k++) {
          if (children[k][this.props.extraMsg]) {
            textObject = {
              left: k * (divid.brother + childSize.width) + rowLeft[i + offset],
              top: endY,
              value: children[k][this.props.extraMsg],
              reactKey: children[k].reactKey + 'txt'
            };
            if (this.state.path.indexOf(children[k].nodeLayoutId) !== -1) {
              textObject.focus = true;
            }
            texts.push(textObject);
          }
        }
      }
    }

    var linePath = this.drawPath(lines, '#c1bebe');
    var focusLinePath = this.drawPath(focusLines, '#2db7f5');
    var extraTexts = this.drawText(texts);
    var svgContent = _react2["default"].createElement(
      'svg',
      { width: svgWidth, height: svgHeight, className: 'path-container' },
      linePath,
      focusLinePath
    );
    var content = {
      svg: svgContent,
      msg: extraTexts
    };

    return content;
  };

  NodeTree.prototype.drawPath = function drawPath() {
    var pathPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var color = arguments[1];

    if (pathPoints.length === 0) {
      return '';
    }
    var backwards = this.props.backwards;

    var offset = backwards ? -30 : 30;
    var arrowY = backwards ? -4 : 4;
    var pathD = '';
    var pathPoint = {};

    for (var i = 0; i < pathPoints.length; i++) {
      pathPoint = pathPoints[i];
      pathD += '\n        M ' + pathPoint.startX + ' ' + pathPoint.startY + '\n        C ' + pathPoint.startX + ' ' + (pathPoint.startY + offset) + ' ' + pathPoint.endX + ' ' + (pathPoint.endY - offset) + '\n        ' + pathPoint.endX + ' ' + pathPoint.endY + '\n      '; // 连接两个结点的一条线
      if (this.props.showDirectArrow) {
        pathD += '\n          M ' + pathPoint.endX + ' ' + pathPoint.endY + ' L ' + (pathPoint.endX - 4) + ' ' + (pathPoint.endY - arrowY) + '\n          M ' + pathPoint.endX + ' ' + pathPoint.endY + ' L ' + (pathPoint.endX + 4) + ' ' + (pathPoint.endY - arrowY) + '\n        ';
      }
    }
    var path = _react2["default"].createElement('path', { d: pathD, stroke: color, fill: 'transparent' });

    return path;
  };

  NodeTree.prototype.drawText = function drawText() {
    var texts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var backwards = this.props.backwards;
    var width = this.props.childSize.width;

    var textYOffset = backwards ? -5 : 5;
    var msgHeight = backwards ? 0 : 20;

    if (texts.length === 0) {
      return '';
    }

    var style = {};
    var content = texts.map(function (item) {
      style = {
        position: 'absolute',
        left: item.left,
        top: item.top - textYOffset - msgHeight,
        width: width,
        fontSize: 14,
        textAlign: 'center'
      };
      return _react2["default"].createElement(
        'div',
        { style: style, key: item.reactKey },
        _react2["default"].createElement(
          'p',
          { style: { display: 'inline', backgroundColor: '#fff', color: item.focus ? '#2db7f5' : '#c1bebe', height: msgHeight } },
          item.value
        )
      );
    });

    return content;
  };

  NodeTree.prototype.render = function render() {
    var layout = []; // 数组里的每一个元素代表树的一层
    var treeData = this.state.treeData;
    var content = [];
    var _props2 = this.props,
        rootSize = _props2.rootSize,
        childSize = _props2.childSize,
        _props2$divid = _props2.divid,
        parent = _props2$divid.parent,
        brother = _props2$divid.brother,
        backwards = _props2.backwards;

    var containerSize = {
      width: document.getElementById(this.props.parentId) ? document.getElementById(this.props.parentId).clientWidth : 0,
      height: document.getElementById(this.props.parentId) ? document.getElementById(this.props.parentId).clientHeight : 0
    };
    var layerContent = '';
    var curWidth = 0;
    var parentLeft = -1;
    var curLeft = 0;

    this.buildLayer(layout, treeData);
    this.rowLeft = [];
    layout.reverse();

    for (var i = 0; i < layout.length; i++) {
      if (parentLeft === -1) {
        // 只在初始化存在，意味着该节点没有父级，为根节点
        curWidth = rootSize.width * layout[i].length + brother * (layout[i].length - 1);
        curLeft = (containerSize.width - 60 - curWidth) / 2;
      } else {
        // 其他情况, 展开层的中线应该和它的父节点的中线重合
        curWidth = childSize.width * layout[i].length + brother * (layout[i].length - 1);
        var index = Number.parseInt(this.state.path[i - 1].split('_')[1], 10);
        var leftOffset = 0;
        if (index === 0) {
          if (i - 1 === 0) {
            leftOffset = rootSize.width / 2;
          } else {
            leftOffset = childSize.width / 2;
          }
        } else {
          leftOffset = (childSize.width + brother) * index + childSize.width / 2;
        }
        curLeft = parentLeft + leftOffset - curWidth / 2;
      }

      if (curLeft < 0 || curLeft > 0 && curLeft < childSize.width) {
        curLeft = 0;
      }

      if (curLeft + curWidth >= containerSize.width - 60) {
        curWidth += 30; // 超出后的右边距
      }

      var style = {
        position: 'relative',
        "float": 'left',
        left: curLeft,
        width: curWidth,
        clear: 'both'
      };

      if (backwards) {
        style.paddingBottom = parent;
      } else {
        style.paddingTop = parent;
      }

      if (i === layout.length - 1) {
        var direct = backwards ? 'paddingTop' : 'paddingBottom';
        style[direct] = parent;
      }
      layerContent = _react2["default"].createElement(
        'div',
        { key: (this.reactKey++).toString(), style: style },
        layout[i]
      );
      content.push(layerContent);
      this.rowLeft.push(curLeft);
      parentLeft = curLeft;
    }

    var extraContent = this.buildPathAndMsg();
    if (backwards) {
      content.reverse();
    }

    return _react2["default"].createElement(
      'div',
      { style: containerSize, className: 'hrui-node-tree' },
      _react2["default"].createElement(
        'div',
        { id: 'main' },
        extraContent.svg,
        extraContent.msg,
        content
      )
    );
  };

  return NodeTree;
}(_react.Component), _class.propTypes = {
  onLoadData: _propTypes2["default"].func,
  renderNode: _propTypes2["default"].func,
  parentId: _propTypes2["default"].string,
  url: _propTypes2["default"].string,
  extraMsg: _propTypes2["default"].string,
  defaultPath: _propTypes2["default"].array,
  queryKeys: _propTypes2["default"].array,
  backwards: _propTypes2["default"].bool,
  showDirectArrow: _propTypes2["default"].bool,
  rootSize: _propTypes2["default"].shape({
    width: _propTypes2["default"].number,
    height: _propTypes2["default"].number
  }),
  childSize: _propTypes2["default"].shape({
    width: _propTypes2["default"].number,
    height: _propTypes2["default"].number
  }),
  divid: _propTypes2["default"].shape({
    brother: _propTypes2["default"].number,
    parent: _propTypes2["default"].number
  })
}, _class.defaultProps = {
  backwards: false,
  showDirectArrow: false,
  rootSize: {
    width: 200,
    height: 100
  },
  childSize: {
    width: 200,
    height: 100
  },
  divid: {
    brother: 25,
    parent: 35
  }
}, _temp);
exports["default"] = NodeTree;
module.exports = exports['default'];