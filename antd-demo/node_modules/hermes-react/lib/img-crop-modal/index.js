'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _modal = require('antd/lib/modal');

var _modal2 = _interopRequireDefault(_modal);

var _message2 = require('antd/lib/message');

var _message3 = _interopRequireDefault(_message2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp;

require('antd/lib/modal/style/css');

require('antd/lib/message/style/css');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Cropper = require('./Cropper');

var _Cropper2 = _interopRequireDefault(_Cropper);

var _View = require('./View');

var _View2 = _interopRequireDefault(_View);

require('./style/index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var noop = function noop() {};

var ImgCropModal = (_temp = _class = function (_Component) {
  _inherits(ImgCropModal, _Component);

  function ImgCropModal(props) {
    _classCallCheck(this, ImgCropModal);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.onChange = function (cropInfo) {
      _this.cropInfo = cropInfo;
      var rate = _this.img.naturalWidth / _this.img.width;
      _this.props.onChange(cropInfo, rate);
    };

    _this.onOk = function () {
      var _this$img = _this.img,
          width = _this$img.width,
          height = _this$img.height,
          naturalWidth = _this$img.naturalWidth,
          naturalHeight = _this$img.naturalHeight;
      var _this$props = _this.props,
          onOk = _this$props.onOk,
          _this$props$modalOpti = _this$props.modalOption,
          modalOption = _this$props$modalOpti === undefined ? {} : _this$props$modalOpti;

      var okCallback = modalOption.onOk || onOk || noop;
      okCallback(_extends({}, _this.cropInfo, { orgWidth: Math.floor(naturalWidth || width), orgHeight: Math.floor(naturalHeight || height), url: _this.props.url }));
    };

    _this.loadImg = function () {
      _this.setState({ loaded: true });
    };

    _this.calFrameWH = function (picW, picH, standardW, standardH) {
      var rate = picW / picH;

      var frameWidth = picW;
      var frameHeight = picH;

      if (rate < standardW / standardH) {
        // 以长度为准
        if (frameWidth > standardW) {
          frameWidth = standardW;
          frameHeight = standardH;
        } else {
          frameHeight = frameWidth / standardW * standardH;
        }
      }

      if (rate >= standardW / standardH) {
        // 以高度为准
        if (frameHeight > standardH) {
          frameWidth = standardW;
          frameHeight = standardH;
        } else {
          frameWidth = frameHeight / standardH * standardW;
        }
      }

      return { frameWidth: Math.floor(frameWidth), frameHeight: Math.floor(frameHeight) };
    };

    _this.transferPosition = function (_ref, PicW) {
      var X = _ref.X,
          Y = _ref.Y,
          width = _ref.width,
          height = _ref.height;

      var rate = _this.img.naturalWidth / PicW;
      var x = X < 1 ? X * ((_this.img.naturalWidth - width) / rate) : X;
      var y = Y < 1 ? Y * ((_this.img.naturalHeight - height) / rate) : Y;
      if (!isNaN(x) && !isNaN(y) && width && height) {
        return { originX: x / rate, originY: y / rate, frameWidth: width / rate, frameHeight: height / rate };
      }
      throw Error('初始化信息不全');
    };

    _this.calMinBound = function (PicW, PicH) {
      var _this$props2 = _this.props,
          maxH = _this$props2.maxH,
          maxW = _this$props2.maxW,
          minW = _this$props2.minW,
          minH = _this$props2.minH,
          initWidth = _this$props2.initWidth,
          initHeight = _this$props2.initHeight,
          rate = _this$props2.rate,
          init = _this$props2.init;

      if (init) {
        return _this.transferPosition(init, PicW);
      }
      if (initWidth || initHeight) {
        // 仅有initHeight和initWidth且为百分比
        if (initWidth && initHeight && !rate && (initHeight < 1 || initWidth < 1)) {
          throw new Error('仅有initHeight和initWidth时不能用百分比');
        }
        // 仅有initHeight和initWidth
        if (initWidth && initHeight && !rate) {
          if (initHeight > PicH || initWidth > PicW) {
            var _initRate = initWidth / initHeight;
            var imgRate = PicW / PicH;
            if (_initRate > imgRate) {
              return { frameHeight: PicW / _initRate, frameWidth: PicW };
            }
            return { frameHeight: PicH, frameWidth: PicH * _initRate };
          }
          return { frameHeight: initHeight, frameWidth: initWidth };
        }
        var initRate = rate || PicW / PicH;
        // 仅有initWidth及rate
        if (initWidth) {
          var _frameWidth = initWidth < 1 ? PicW * initWidth : initWidth;
          var _frameHeight = _frameWidth / initRate;
          if (PicH < _frameHeight) {
            _frameHeight = PicH;
            _frameWidth = PicH * initRate;
          }
          return { frameHeight: Math.floor(_frameHeight), frameWidth: Math.floor(_frameWidth) };
        }
        // 仅有initHeight及rate
        if (initHeight) {
          var _frameHeight2 = initHeight < 1 ? PicH * initHeight : initHeight;
          var _frameWidth2 = _frameHeight2 * initRate;
          if (PicW < _frameWidth2) {
            _frameWidth2 = PicW;
            _frameHeight2 = _frameWidth2 / initRate;
          }
          return { frameHeight: Math.floor(_frameHeight2), frameWidth: Math.floor(_frameWidth2) };
        }
      }

      // 交互要求框大小, 老功能不推荐
      if (PicW > maxW && PicH > maxH) {
        var _this$calFrameWH = _this.calFrameWH(PicW, PicH, maxW, maxH),
            _frameWidth3 = _this$calFrameWH.frameWidth,
            _frameHeight3 = _this$calFrameWH.frameHeight;

        return { frameHeight: Math.floor(_frameHeight3), frameWidth: Math.floor(_frameWidth3) };
      }

      var _this$calFrameWH2 = _this.calFrameWH(PicW, PicH, minW, minH),
          frameWidth = _this$calFrameWH2.frameWidth,
          frameHeight = _this$calFrameWH2.frameHeight;

      return { frameHeight: Math.floor(frameHeight), frameWidth: Math.floor(frameWidth) };
    };

    _this.calPicMinAndMax = function (width, height, rate) {
      var _this$props3 = _this.props,
          maxH = _this$props3.maxH,
          maxW = _this$props3.maxW,
          minW = _this$props3.minW,
          minH = _this$props3.minH,
          _this$props3$minPicW = _this$props3.minPicW,
          minPicW = _this$props3$minPicW === undefined ? 0 : _this$props3$minPicW,
          _this$props3$minPicH = _this$props3.minPicH,
          minPicH = _this$props3$minPicH === undefined ? 0 : _this$props3$minPicH,
          _this$props3$maxPicW = _this$props3.maxPicW,
          maxPicW = _this$props3$maxPicW === undefined ? 0 : _this$props3$maxPicW,
          _this$props3$maxPicH = _this$props3.maxPicH,
          maxPicH = _this$props3$maxPicH === undefined ? 0 : _this$props3$maxPicH;
      var clientHeight = document.documentElement.clientHeight;
      // 小于给定值强拉到更定值

      var actureMaxW = maxPicW || maxPicH ? maxPicW ? maxPicW : maxPicH * rate : maxW;
      var actureMaxH = maxPicH || maxPicW ? maxPicH ? maxPicH : maxPicW / rate : maxH;
      var actureMinW = minPicW || minPicH ? minPicW ? minPicW : minPicH * rate : minW;
      var actureMinH = minPicH || minPicW ? minPicH ? minPicH : minPicW / rate : minH;
      actureMinW = actureMinW < 133 ? 133 : actureMinW;
      actureMaxW = actureMaxW < 133 ? 133 : actureMaxW;
      actureMaxH = actureMaxH > clientHeight - 104 ? clientHeight - 104 : actureMaxH;

      if (actureMinH && actureMinW / rate > actureMinH) {
        actureMinW = actureMinH * rate;
      } else if (actureMinW) {
        actureMinH = actureMinW / rate;
      }
      if (actureMaxH && actureMaxW / rate > actureMaxH) {
        actureMaxW = actureMaxH * rate;
      } else if (actureMaxW) {
        actureMaxH = actureMaxW / rate;
      }
      return { actureMinH: actureMinH, actureMinW: actureMinW, actureMaxH: actureMaxH, actureMaxW: actureMaxW };
    };

    _this.calPicWH = function () {
      var _this$props$style = _this.props.style,
          boundW = _this$props$style.width,
          boundH = _this$props$style.height;
      var _this$img2 = _this.img,
          width = _this$img2.width,
          height = _this$img2.height;

      var rate = width / height;
      var PicW = void 0,
          PicH = void 0;

      if (!boundW && !boundH) {
        var _this$calPicMinAndMax = _this.calPicMinAndMax(width, height, rate),
            actureMinH = _this$calPicMinAndMax.actureMinH,
            actureMinW = _this$calPicMinAndMax.actureMinW,
            actureMaxH = _this$calPicMinAndMax.actureMaxH,
            actureMaxW = _this$calPicMinAndMax.actureMaxW;
        // 小于给定值强拉到更定值


        PicW = width < actureMinW ? actureMinW : width;
        PicH = height < actureMinH ? actureMinH : height;
        // 限制图片宽高
        PicW = actureMaxW < PicW ? actureMaxW : PicW;
        PicH = actureMaxH < PicH ? actureMaxH : PicH;
      } else {
        var boundHeight = parseInt(boundH);
        var boundWidth = parseInt(boundW);
        if (boundH && boundW) {
          var boundRate = boundWidth / boundHeight;
          if (boundRate > rate) {
            PicW = boundHeight * rate;
            PicH = boundHeight;
          } else {
            PicW = boundWidth;
            PicH = boundWidth / rate;
          }
        } else {
          PicH = !boundH ? boundWidth / rate : boundHeight;
          PicW = !boundW ? boundHeight * rate : boundWidth;
        }
      }

      if (PicH !== height || PicW !== width) {
        if (rate < 1) {
          PicH = PicW / rate;
        } else {
          PicW = PicH * rate;
        }
      }

      return { PicW: Math.floor(PicW), PicH: Math.floor(PicH) };
    };

    _this.getDrageLimit = function (width, height) {
      var _this$props4 = _this.props,
          dragMin = _this$props4.dragMin,
          dragMax = _this$props4.dragMax;

      var limitInfo = {}; // max需小于min
      if (dragMax) {
        var originValue = dragMax.type === 'height' ? height : width;
        limitInfo['max'] = _extends({}, dragMax, { value: dragMax.value < 1 ? dragMax.value * originValue : dragMax.value });
      }
      if (dragMin) {
        var _originValue = dragMin.type === 'height' ? height : width;
        limitInfo['min'] = _extends({}, dragMin, { value: dragMin.value < 1 ? dragMin.value * _originValue : dragMin.value });
      }
      if (dragMax && dragMin && dragMax.type === dragMin.type && limitInfo.min.value > limitInfo.max.value) {
        throw new Error('可拖拽最小值大于最大值');
      }
      return limitInfo;
    };

    _this.state = {
      loaded: false
    };
    return _this;
  }

  ImgCropModal.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var img = this.img = new Image();
    img.onload = this.loadImg;
    img.onerror = function () {
      _message3["default"].error('图片加载失败，请重试');_this2.img = null;_this2.props.onCancel();
    };
    img.src = this.props.url;
  };

  // 截图区域计算规则,根本不可能出现1242的宽，因为浮层限制。。。
  // 1.如果图片双边均大于等于1242 ＊ 600 截图区域1242 ＊ 600，且可缩放至750 (由于宽高比要保持为1242).
  // 2.如果图片双边均小于1242以 750 ＊ 360来裁剪.
  // 3.均可放大到占满图片一边.

  // 截图区域处理规则
  // 1.截图区域宽高大于图片宽高需做缩放。
  // 2.且截图区域只能放大，不能缩小


  /* eslint-disable */


  // 限定宽高情况下，重新计算图片宽高
  // 截图图片处理规则
  // 1.高度需小于界面高度，宽度小于给定的边界宽度
  // 2.宽高小于给定值需要强拉到大的边在给定值
  /* eslint-disable */


  ImgCropModal.prototype.render = function render() {
    var loaded = this.state.loaded;
    var _props = this.props,
        minW = _props.minW,
        minH = _props.minH,
        url = _props.url,
        type = _props.type,
        isModal = _props.isModal,
        style = _props.style,
        over = _props.over,
        _props$modalOption = _props.modalOption,
        modalOption = _props$modalOption === undefined ? {} : _props$modalOption,
        onCancel = _props.onCancel;

    var cancelCallback = modalOption.onCancel || onCancel || noop;
    if (!loaded) {
      return _react2["default"].createElement('div', null);
    }

    var _calPicWH = this.calPicWH(),
        PicW = _calPicWH.PicW,
        PicH = _calPicWH.PicH;

    var _calMinBound = this.calMinBound(PicW, PicH),
        frameHeight = _calMinBound.frameHeight,
        frameWidth = _calMinBound.frameWidth,
        _calMinBound$originX = _calMinBound.originX,
        originX = _calMinBound$originX === undefined ? 0 : _calMinBound$originX,
        _calMinBound$originY = _calMinBound.originY,
        originY = _calMinBound$originY === undefined ? 0 : _calMinBound$originY;

    var topV = Math.floor(document.documentElement.clientHeight - PicH - 104) / 2;
    var dragLimit = this.getDrageLimit(PicW, PicH);
    var CropDom = _react2["default"].createElement(_Cropper2["default"], _extends({}, dragLimit, { over: over, style: style, type: type, originX: originX, originY: originY, src: url, onChange: this.onChange, minWidth: frameWidth < minW ? frameWidth : minW, minHeight: frameHeight < minH ? frameHeight : minH, frameHeight: frameHeight, frameWidth: frameWidth, imgHeight: Math.floor(PicH), imgWidth: PicW, rate: frameWidth / frameHeight }));

    return _react2["default"].createElement(
      'div',
      null,
      isModal ? _react2["default"].createElement(
        _modal2["default"],
        _extends({}, modalOption, { maskClosable: false, visible: this.props.visible, width: PicW + 32, onOk: this.onOk, style: { top: topV + 'px' }, onCancel: cancelCallback }),
        _react2["default"].createElement(
          'div',
          { style: _extends({}, style, { marginTop: 20 }) },
          CropDom
        )
      ) : _react2["default"].createElement(
        'div',
        { style: _extends({}, style) },
        CropDom
      )
    );
  };

  return ImgCropModal;
}(_react.Component), _class.propTypes = {
  url: _propTypes2["default"].string,
  onChange: _propTypes2["default"].func,
  onOk: _propTypes2["default"].func,
  onCancel: _propTypes2["default"].func,
  minH: _propTypes2["default"].number,
  minW: _propTypes2["default"].number,
  maxW: _propTypes2["default"].number,
  maxH: _propTypes2["default"].number,
  minPicW: _propTypes2["default"].number,
  minPicH: _propTypes2["default"].number,
  maxPicW: _propTypes2["default"].number,
  maxPicH: _propTypes2["default"].number,
  visible: _propTypes2["default"].bool,
  isModal: _propTypes2["default"].bool,
  style: _propTypes2["default"].object,
  initWidth: _propTypes2["default"].number,
  initHeight: _propTypes2["default"].number,
  rate: _propTypes2["default"].number,
  dragMin: _propTypes2["default"].object,
  dragMax: _propTypes2["default"].object,
  over: _propTypes2["default"].bool,
  modalOption: _propTypes2["default"].object,
  type: _propTypes2["default"].oneOf(['position', 'base64'])
}, _class.defaultProps = {
  minH: 360,
  minW: 720,
  maxH: 600,
  maxW: 1242,
  maxPicW: 0, // 真正的最小值
  maxPicH: 0,
  minPicW: 133,
  minPicH: 0,
  type: 'position',
  PropTypes: {},
  visible: true,
  isModal: true,
  onChange: noop,
  style: {}
}, _temp);


ImgCropModal.Preview = _View2["default"];
exports["default"] = ImgCropModal;
module.exports = exports['default'];