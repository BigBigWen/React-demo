'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _class, _temp, _initialiseProps;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var isIE = window.navigator.userAgent.toLowerCase().indexOf('msie') > 0;
var Cropper = (_temp = _class = function (_Component) {
  _inherits(Cropper, _Component);

  function Cropper(props) {
    _classCallCheck(this, Cropper);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _initialiseProps.call(_this);

    var originX = props.originX;
    var originY = props.originY;
    // const width = tempProps.width;
    // const rate = tempProps.rate;
    var frameWidth = props.frameWidth;
    var frameHeight = props.frameHeight;
    _this.state = {
      img_width: '100%',
      img_height: '',
      originX: originX,
      originY: originY,
      startX: 0,
      startY: 0,
      frameWidth: frameWidth,
      frameHeight: frameHeight,
      dragging: false,
      maxLeft: 0,
      maxTop: 0,
      action: null,
      imgLoaded: false
    };
    return _this;
  }
  /* eslint-disable */


  /* eslint-disable */


  Cropper.prototype.render = function render() {
    var _this2 = this;

    var className = ['_cropper'];
    var _state = this.state,
        imgLoaded = _state.imgLoaded,
        dragging = _state.dragging,
        imgHeight = _state.img_height,
        imgWidth = _state.img_width;
    var _props = this.props,
        src = _props.src,
        disabled = _props.disabled,
        style = _props.style;
    var height = style.height,
        width = style.width;


    if (imgLoaded) className.push('_loaded');
    if (dragging) className.push('_dragging');
    className = className.join(' ');
    if (disabled) className = '_cropper _disabled';
    var hasH = !!Number(imgWidth);
    var imageNode = _react2["default"].createElement('img', { src: src, ref: function ref(node) {
        _this2.img = node;
      }, width: imgWidth, onLoad: !hasH ? this.imgOnload : undefined, height: hasH ? imgHeight : undefined });

    var node = disabled ? _react2["default"].createElement(
      'div',
      { className: className, ref: function ref(n) {
          _this2.container = n;
        }, style: hasH ? {
          position: 'relative',
          width: width || imgWidth
        } : {
          position: 'relative'
        } },
      _react2["default"].createElement(
        'div',
        { className: '_source', ref: function ref(node) {
            _this2.sourceNode = node;
          } },
        imageNode
      ),
      _react2["default"].createElement('div', { className: '_modal' })
    ) : _react2["default"].createElement(
      'div',
      { className: className, onMouseLeave: this.handleDragStop, onMouseMove: this.handleDrag, onMouseDown: this.handleDragStart, onMouseUp: this.handleDragStop, ref: function ref(n) {
          _this2.container = n;
        }, style: {
          position: 'relative',
          height: height || imgHeight,
          lineHeight: (height || imgHeight) + 'px',
          width: width || imgWidth
        } },
      _react2["default"].createElement(
        'div',
        { className: '_source', ref: function ref(node) {
            _this2.sourceNode = node;
          } },
        imageNode,
        _react2["default"].createElement(
          'div',
          { className: '_frame', ref: function ref(n) {
              _this2.frameNode = n;
            } },
          _react2["default"].createElement(
            'div',
            { className: '_clone' },
            _react2["default"].createElement('img', { src: src, ref: function ref(n) {
                _this2.cloneImg = n;
              }, width: imgWidth, height: hasH ? imgHeight : undefined })
          ),
          _react2["default"].createElement('span', { className: '_move', 'data-action': 'move' }),
          _react2["default"].createElement('span', { className: '_dot _dot-center', 'data-action': 'ne' }),
          _react2["default"].createElement('span', { className: '_dot _dot-ne', 'data-action': 'ne' }),
          _react2["default"].createElement('span', { className: '_dot _dot-n', 'data-action': 'n' }),
          _react2["default"].createElement('span', { className: '_dot _dot-nw', 'data-action': 'nw' }),
          _react2["default"].createElement('span', { className: '_dot _dot-e', 'data-action': 'e' }),
          _react2["default"].createElement('span', { className: '_dot _dot-w', 'data-action': 'w' }),
          _react2["default"].createElement('span', { className: '_dot _dot-se', 'data-action': 'se' }),
          _react2["default"].createElement('span', { className: '_dot _dot-s', 'data-action': 's' }),
          _react2["default"].createElement('span', { className: '_dot _dot-sw', 'data-action': 'sw' }),
          _react2["default"].createElement('span', { className: '_line _line-n', 'data-action': 'n' }),
          _react2["default"].createElement('span', { className: '\'_line _line-s', 'data-action': 's' }),
          _react2["default"].createElement('span', { className: '_line _line-w', 'data-action': 'w' }),
          _react2["default"].createElement('span', { className: '_line _line-e', 'data-action': 'e' })
        )
      ),
      _react2["default"].createElement('div', { className: '_modal' })
    );

    return node;
  };

  return Cropper;
}(_react.Component), _class.propTypes = {
  imgHeight: _propTypes2["default"].number,
  imgWidth: _propTypes2["default"].number,
  frameWidth: _propTypes2["default"].number,
  frameHeight: _propTypes2["default"].number,
  onChange: _propTypes2["default"].func,
  src: _propTypes2["default"].string.isRequired,
  originX: _propTypes2["default"].number,
  originY: _propTypes2["default"].number,
  rate: _propTypes2["default"].number,
  width: _propTypes2["default"].number,
  disabled: _propTypes2["default"].bool,
  style: _propTypes2["default"].object,
  max: _propTypes2["default"].object,
  min: _propTypes2["default"].object,
  type: _propTypes2["default"].oneOf(['position', 'base64'])
}, _class.defaultProps = {
  width: 200,
  over: false,
  rate: 1,
  originX: 0,
  originY: 0,
  style: {}
}, _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.initStyles = function () {
    var tempThis = _this3;
    var _props2 = _this3.props,
        imgHeight = _props2.imgHeight,
        imgWidth = _props2.imgWidth;

    // calc frame width height

    var tempProps2 = tempThis.props;
    var originX = tempProps2.originX;
    var originY = tempProps2.originY;
    var disabled = tempProps2.disabled;

    if (disabled) return;
    var tempState = tempThis.state;
    var frameWidth = tempState.frameWidth;
    var frameHeight = tempState.frameHeight;

    var maxLeft = imgWidth - frameWidth;
    var maxTop = imgHeight - frameHeight;

    if (originX + frameWidth >= imgWidth) {
      originX = imgWidth - frameWidth;
      tempThis.setState({
        originX: originX
      });
    }
    if (originY + frameHeight >= imgHeight) {
      originY = imgHeight - frameHeight;
      tempThis.setState({
        originY: originY
      });
    }

    tempThis.setState({
      maxLeft: maxLeft,
      maxTop: maxTop,
      imgLoaded: true
    });

    tempThis.calcPosition(frameWidth, frameHeight, originX, originY);
  };

  this.calcPosition = function (argWidth, argHeight, argLeft, argTop, isMove) {
    var _state2 = _this3.state,
        imgWidth = _state2.img_width,
        imgHeight = _state2.img_height;
    var _props3 = _this3.props,
        minWidth = _props3.minWidth,
        minHeight = _props3.minHeight,
        rate = _props3.rate,
        over = _props3.over,
        min = _props3.min,
        max = _props3.max,
        style = _props3.style,
        _props3$onChange = _props3.onChange,
        onChange = _props3$onChange === undefined ? function () {} : _props3$onChange;
    var _style$width = style.width,
        boundWidth = _style$width === undefined ? imgWidth : _style$width,
        _style$height = style.height,
        boundHeight = _style$height === undefined ? imgHeight : _style$height;

    var frameNode = _this3.frameNode;
    var cloneImg = _this3.cloneImg;
    var width = argWidth;
    var height = argHeight;
    var left = argLeft;
    var top = argTop;
    var topLimit = (boundHeight - imgHeight) / -2;
    var leftLimit = (boundWidth - imgWidth) / -2;

    if (!over) {
      if (!min && !max && !isMove) {
        if (width < minWidth || height < minHeight) return false;
        if (width < 0 || height < 0) return false;
      }
      if (left < 0) {
        left = 0;
      }
      if (top < 0) {
        top = 0;
      }
    }

    if (width / boundWidth > height / boundHeight) {
      if (width > boundWidth) {
        width = boundWidth;
        left = leftLimit;
        height = width / rate;
      }
    } else if (height > boundHeight) {
      height = boundHeight;
      top = topLimit;
      width = height * rate;
    }

    if (width - leftLimit + left > boundWidth) left = boundWidth - width + leftLimit;
    if (height - topLimit + top > boundHeight) top = boundHeight - height + topLimit;
    if (left < leftLimit) left = leftLimit;
    if (top < topLimit) top = topLimit;

    // 对应dragmin，dragmax
    // width = max.type === 'width' && max.value

    frameNode.setAttribute('style', 'display:block;left:' + left + 'px;top:' + top + 'px;width:' + width + 'px;height:' + height + 'px');
    cloneImg.setAttribute('style', 'transform: translate(' + -left + 'px, ' + -top + 'px)');
    onChange(_this3.getCropInfo(left, top, width, height));
  };

  this.imgOnload = function () {
    var _props4 = _this3.props,
        imgHeight = _props4.imgHeight,
        imgWidth = _props4.imgWidth;

    _this3.setState({
      img_height: imgHeight,
      img_width: imgWidth
    }, function () {
      return _this3.initStyles();
    });
  };

  this.createNewFrame = function (e) {
    if (_this3.state.dragging) {
      var pageX = isIE ? e.clientX : e.pageX;
      var pageY = isIE ? e.clientY : e.pageY;
      var rate = _this3.props.rate;
      var tempState3 = _this3.state;
      var frameWidth = tempState3.frameWidth;
      var startX = tempState3.startX;
      var startY = tempState3.startY;
      var offsetLeft = tempState3.offsetLeft;
      var offsetTop = tempState3.offsetTop;

      var tempX = pageX - startX;
      var tempY = pageY - startY;

      if (tempX > 0) {
        if (tempY < 0) return _this3.calcPosition(frameWidth + tempX, (frameWidth + tempX) / rate, offsetLeft, offsetTop - tempX / rate);
        return _this3.calcPosition(frameWidth + tempX, (frameWidth + tempX) / rate, offsetLeft, offsetTop);
      }
      if (tempY > 0) return _this3.calcPosition(frameWidth - tempX, (frameWidth - tempX) / rate, offsetLeft + tempX, offsetTop);
      return _this3.calcPosition(frameWidth - tempX, (frameWidth - tempX) / rate, offsetLeft + tempX, offsetTop + tempX / rate);
    }
  };

  this.handleDrag = function (e) {
    if (_this3.state.dragging) {
      var action = _this3.state.action;

      if (!action) return _this3.createNewFrame(e);
      if (action === 'move') return _this3.frameMove(e);
      _this3.frameDotMove(action, e);
    }
  };

  this.frameMove = function (e) {
    var _state3 = _this3.state,
        originX = _state3.originX,
        originY = _state3.originY,
        startX = _state3.startX,
        startY = _state3.startY,
        frameWidth = _state3.frameWidth,
        frameHeight = _state3.frameHeight,
        maxLeft = _state3.maxLeft,
        maxTop = _state3.maxTop;

    var pageX = isIE ? e.clientX : e.pageX;
    var pageY = isIE ? e.clientY : e.pageY;
    var tempX = pageX - startX + originX;
    var tempY = pageY - startY + originY;
    if (!_this3.props.over) {
      if (pageX < 0 || pageY < 0) return false;
      if (tempX > maxLeft) tempX = maxLeft;
      if (tempY > maxTop) tempY = maxTop;
    }
    _this3.calcPosition(frameWidth, frameHeight, tempX, tempY, true);
  };

  this.handleDragStart = function (e) {
    e.preventDefault();
    var tempThis3 = _this3;
    var pageX = isIE ? e.clientX : e.pageX;
    var pageY = isIE ? e.clientY : e.pageY;
    var action = e.target.getAttribute('data-action') || 'move';
    // fix IE probleum
    _this3.setState({
      startX: pageX,
      startY: pageY,
      dragging: true,
      action: action
    });
    if (!action) {
      (function fn() {
        var container = tempThis3.container;
        var offsetLeft = container.offsetLeft;
        var offsetTop = container.offsetTop;
        tempThis3.setState({
          offsetLeft: pageX - offsetLeft,
          offsetTop: pageY - offsetTop,
          frameWidth: 2,
          frameHeight: 2
        }, function () {
          tempThis3.calcPosition(2, 2, pageX - offsetLeft, pageY - offsetTop);
        });
      })();
    }
  };

  this.handleDragStop = function () {
    var frameNode = _this3.frameNode;
    var offsetLeft = frameNode.offsetLeft;
    var offsetTop = frameNode.offsetTop;
    var offsetWidth = frameNode.offsetWidth;
    var offsetHeight = frameNode.offsetHeight;
    var tempState5 = _this3.state;
    var imgWidth = tempState5.img_width;
    var imgHeight = tempState5.img_height;
    _this3.setState({
      originX: offsetLeft,
      originY: offsetTop,
      dragging: false,
      frameWidth: offsetWidth,
      frameHeight: offsetHeight,
      maxLeft: imgWidth - offsetWidth,
      maxTop: imgHeight - offsetHeight,
      action: null
    });
  };

  this.judgeLimit = function (width, height, cb) {
    var _props5 = _this3.props,
        _props5$min = _props5.min,
        min = _props5$min === undefined ? {} : _props5$min,
        _props5$max = _props5.max,
        max = _props5$max === undefined ? {} : _props5$max;

    if (min.type === 'height' && !(min.value < height)) {
      return;
    }
    if (min.type === 'width' && !(min.value < width)) {
      return;
    }
    if (max.type === 'height' && !(max.value > height)) {
      return;
    }
    if (max.type === 'width' && !(max.value > width)) {
      return;
    }
    cb();
  };

  this.frameDotMove = function (dir, e) {
    var pageX = isIE ? e.clientX : e.pageX;
    var pageY = isIE ? e.clientY : e.pageY;
    var _props6 = _this3.props,
        over = _props6.over,
        rate = _props6.rate;
    var _state4 = _this3.state,
        startX = _state4.startX,
        startY = _state4.startY,
        originX = _state4.originX,
        originY = _state4.originY,
        frameHeight = _state4.frameHeight,
        frameWidth = _state4.frameWidth;


    if (over || pageY !== 0 && pageX !== 0) {
      var tempX = pageX - startX;
      var tempY = pageY - startY;
      var newWidth = frameWidth + tempX;
      var newHeight = newWidth / rate;
      switch (dir) {
        case 'ne':
          _this3.judgeLimit(newWidth, newWidth / rate, function () {
            _this3.calcPosition(newWidth, newHeight, originX, originY - tempX / rate);
          });
          return;
        case 'e':
          _this3.judgeLimit(newWidth, newWidth / rate, function () {
            _this3.calcPosition(newWidth, newHeight, originX, originY - tempX / rate * 0.5);
          });
          return;
        case 'se':
          _this3.judgeLimit(newWidth, newWidth / rate, function () {
            _this3.calcPosition(newWidth, newHeight, originX, originY);
          });
          return;
        case 'n':
          newHeight = frameHeight - tempY;
          _this3.judgeLimit(newHeight * rate, newHeight, function () {
            _this3.calcPosition(newHeight * rate, newHeight, originX + tempY * rate * 0.5, originY + tempY);
          });
          return;
        case 'nw':
          newWidth = frameWidth - tempX;
          _this3.judgeLimit(newWidth, newWidth / rate, function () {
            _this3.calcPosition(newWidth, newWidth / rate, originX + tempX, originY + tempX / rate);
          });
          return;
        case 'w':
          newWidth = frameWidth - tempX;
          _this3.judgeLimit(newWidth, newWidth / rate, function () {
            _this3.calcPosition(newWidth, newWidth / rate, originX + tempX, originY + tempX / rate * 0.5);
          });
          return;
        case 'sw':
          newWidth = frameWidth - tempX;
          _this3.judgeLimit(newWidth, newWidth / rate, function () {
            _this3.calcPosition(newWidth, newWidth / rate, originX + tempX, originY);
          });
          return;
        case 's':
          newHeight = frameHeight + tempY;
          _this3.judgeLimit(newHeight * rate, newHeight, function () {
            _this3.calcPosition(newHeight * rate, newHeight, originX - tempY * rate * 0.5, originY);
          });
          return;
        default:
          return '';
      }
    }
  };

  this.crop = function () {
    var tempState7 = _this3.state;
    var frameWidth = tempState7.frameWidth;
    var frameHeight = tempState7.frameHeight;
    var originX = tempState7.originX;
    var originY = tempState7.originY;
    var imgWidth = tempState7.img_width;

    var canvas = document.createElement('canvas');
    var img = _this3.img;
    var rate = img.naturalWidth / imgWidth;
    var realWidth = frameWidth * rate;
    var realHeight = frameHeight * rate;
    canvas.width = realWidth;
    canvas.height = realHeight;

    canvas.getContext('2d').drawImage(img, originX * rate, originY * rate, realWidth, realHeight, 0, 0, realWidth, realHeight);
    return canvas.toDataURL();
  };

  this.getCropInfo = function (x, y, frameWidth, frameHeight) {
    var tempState7 = _this3.state;
    var imgWidth = tempState7.img_width;

    var img = _this3.img;
    var rate = img.naturalWidth / imgWidth;
    var realWidth = frameWidth * rate;
    var realHeight = frameHeight * rate;

    var X = Math.floor(x * rate);
    var Y = Math.floor(y * rate);
    var width = Math.floor(realWidth);
    var height = Math.floor(realHeight);

    if (_this3.props.type === 'base64') {
      return _this3.crop(); // 不支持own模式
    }
    if (_this3.props.over) {
      var valid = { X: X < 0 ? 0 : X, Y: Y < 0 ? 0 : Y };
      var padOverY = Y + height - img.naturalHeight;
      var padOverX = X + width - img.naturalWidth;
      valid.height = height + (Y < 0 ? Y : 0) - (padOverY > 0 ? padOverY : 0);
      valid.width = width + (X < 0 ? X : 0) - (padOverX > 0 ? padOverX : 0);
      return { X: X, Y: Y, width: width, height: height, valid: valid, imgWidth: img.naturalWidth, imgHeight: img.naturalHeight };
    }
    return { X: X, Y: Y, width: width, height: height, imgWidth: img.naturalWidth, imgHeight: img.naturalHeight };
  };
}, _temp);
exports["default"] = Cropper;
module.exports = exports['default'];